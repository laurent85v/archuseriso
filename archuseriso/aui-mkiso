#!/usr/bin/env bash
#
# SPDX-License-Identifier: GPL-3.0-or-later

set -e -u

# Control the environment
umask 0022
export LC_ALL="C"
[[ -v SOURCE_DATE_EPOCH ]] || printf -v SOURCE_DATE_EPOCH '%(%s)T' -1
export SOURCE_DATE_EPOCH
SCRIPTUSER="${SUDO_USER:-}"

# Set application name from the script's file name
app_name="${0##*/}"

# Global variables.
airootfs_image_type="squashfs"
airootfs_image_tool_options=()
arch="$(uname -m)"
bootmodes=()
bootstrap_packages=""
bootstrap_pkg_list=()
buildmodes=()
build_zfs_packages="n"
cert_list=()
directory_profiles="/usr/share/archuseriso/profiles"
desktop=""
embed_dir=""
gpg_key=""
gpg_sender=""
image_name=""
install_dir=""
iso_application=""
iso_label=""
iso_name="${app_name}"
iso_publisher=""
iso_version=""
iso_version_options=()
lang=""
out_dir=""
packages=""
packages_locales=""
pacman_conf=""
pacman_testing_conf=""
pacstrap_dir=""
pkg_list=()
pkg_list_additions=()
pkg_testing_list=()
profile=""
quiet=""
sign_netboot_artifacts=""
user_pkg_dir=""
work_dir=""
declare -A file_permissions=()
# adapted from GRUB_EARLY_INITRD_LINUX_STOCK in https://git.savannah.gnu.org/cgit/grub.git/tree/util/grub-mkconfig.in
readonly ucodes=('intel-uc.img' 'intel-ucode.img' 'amd-uc.img' 'amd-ucode.img' 'early_ucode.cpio' 'microcode.cpio')

# Show an INFO message
# $1: message string
_msg_info() {
    local _msg="${1}"
    printf '[%s] INFO: %s\n' "${app_name}" "${_msg}"
}

# Show a WARNING message
# $1: message string
_msg_warning() {
    local _msg="${1}"
    printf '[%s] WARNING: %s\n' "${app_name}" "${_msg}" >&2
}

# Show an ERROR message then exit with status
# $1: message string
# $2: exit code number (with 0 does not exit)
_msg_error() {
    local _msg="${1}"
    local _error=${2}
    printf '[%s] ERROR: %s\n' "${app_name}" "${_msg}" >&2
    if (( _error > 0 )); then
        exit "${_error}"
    fi
}

# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
    IFS='' read -r -d '' usagetext <<ENDUSAGETEXT || true
usage: ${app_name} [options] <profile_dir>
  options:
     -A, --application  <application>   Set an application name for the ISO
                                        Default: '${iso_application}'
     --add-pkg, -p     PACKAGE(S)       Package(s) to install, comma seperated list
     --add-pkg-testing PACKAGE(S)       Package(s) to install from testing repositories,
                                        comma seperated list
     --add-i3-wm                        Add i3wm packages: i3-gaps,feh,dmenu,i3status,wmctrl
     -c, --cert [cert ..]               Provide certificates for codesigning of netboot artifacts
                                        Multiple files are provided as quoted, comma delimited list.
                                        The first file is considered as the signing certificate,
                                        the second as the key.
     -C <file>                          pacman configuration file.
                                        Default: '${pacman_conf}'
     -D, --install-dir  <install_dir>   Set an install_dir. All files will by located here.
                                        Default: '${install_dir}'
                                        NOTE: Max 8 characters, use only [a-z0-9]
     --embed-dir <path>                 Embed directory contents in the iso image,
                                        data available from the live's session.
     -g, --gpgkey <gpg_key>             Set the PGP key ID to be used for signing the rootfs image.
                                        Passed to gpg as the value for --default-key
     -G, --gpgsender <mbox>             Set the PGP signer (must include an email address)
                                        Passed to gpg as the value for --sender
     -h                                 This message
     -L <label>                         Set the ISO volume label
                                        Default: '${iso_label}'
     -l, --language <lang>              Set default language, select one from:
                                        cz, de, es, fr, gr, hu, it, nl, pl, pt, ro, rs, ru, tr, ua
     -m, --build-modes [build modes]    Build modes to use (valid modes are: 'bootstrap' and 'iso').
                                        Multiple build modes are provided as quoted, comma delimited list.
     --nvidia                           Nvidia graphics driver setup
     --optimus                          For Optimus hardware, set Intel iGPU default and Nvidia dGPU
                                        configured for PRIME render offload (prime-run <application>)
     -o <out_dir>                       Set the output directory
                                        Default: '${out_dir}'
     --pacman-testing-conf <file>       pacman configuration file with testing repositories enabled.
                                        Default: '${pacman_testing_conf}'
     --pkg-dir <path>                   Directory containing user packages to install,
                                        pkg.tar.xz or pkg.tar.zst package files.
     -P <publisher>                     Set the ISO publisher
                                        Default: '${iso_publisher}'
     -v, --verbose                      Enable verbose output
     -w, --work-dir <work_dir>          Set the working directory
                                        Default: '${work_dir}'
     --zfs                              Dynamically builds the ZFS packages against installed
                                        kernel and install packages.

  profile_dir:        Directory of the archuseriso profile to build. Available directory profiles
                      under /usr/share/archuseriso/profiles

  Build example:
  sudo ${app_name} /usr/share/archuseriso/profiles/xfce

  Customization:
  Copy the directory profile to an new location then edit profiledef.sh and packages.x86_64
                     

ENDUSAGETEXT
    printf '%s' "${usagetext}"
    exit "${1}"
}

# Shows configuration options.
_show_config() {
    local build_date
    printf -v build_date '%(%FT%R%z)T' "${SOURCE_DATE_EPOCH}"
    _msg_info "${app_name} configuration settings"
    _msg_info "             Architecture:   ${arch}"
    _msg_info "        Working directory:   ${work_dir}"
    _msg_info "   Installation directory:   ${install_dir}"
    _msg_info "               Build date:   ${build_date}"
    _msg_info "         Output directory:   ${out_dir}"
    _msg_info "       Current build mode:   ${buildmode}"
    _msg_info "              Build modes:   ${buildmodes[*]}"
    _msg_info "                  GPG key:   ${gpg_key:-None}"
    _msg_info "               GPG signer:   ${gpg_sender:-None}"
    _msg_info "                  Profile:   ${profile}"
    _msg_info "Code signing certificates:   ${cert_list[*]:-None}"
    _msg_info "Pacman configuration file:   ${pacman_conf}"
    _msg_info "Pacman testing conf. file:   ${pacman_testing_conf}"
    _msg_info "         ISO volume label:   ${iso_label}"
    _msg_info "            ISO publisher:   ${iso_publisher}"
    _msg_info "          ISO application:   ${iso_application}"
    _msg_info "               Boot modes:   ${bootmodes[*]:-None}"
    _msg_info "    Packages from testing:   ${pkg_testing_list[*]}"
    _msg_info "  User packages directory:   ${user_pkg_dir}"
    _msg_info "            Packages File:   ${buildmode_packages}"
    _msg_info "                 Packages:   ${buildmode_pkg_list[*]}"
}

# Cleanup airootfs
_cleanup_pacstrap_dir() {
    _msg_info "Cleaning up in pacstrap location..."

    # Delete all files in /boot
    [[ -d "${pacstrap_dir}/boot" ]] && find "${pacstrap_dir}/boot" -mindepth 1 -delete
    # Delete pacman database sync cache files (*.tar.gz)
    [[ -d "${pacstrap_dir}/var/lib/pacman" ]] && find "${pacstrap_dir}/var/lib/pacman" -maxdepth 1 -type f -delete
    # Delete pacman database sync cache
    [[ -d "${pacstrap_dir}/var/lib/pacman/sync" ]] && find "${pacstrap_dir}/var/lib/pacman/sync" -delete
    # Delete pacman package cache
    [[ -d "${pacstrap_dir}/var/cache/pacman/pkg" ]] && find "${pacstrap_dir}/var/cache/pacman/pkg" -type f -delete
    # Delete all log files, keeps empty dirs.
    [[ -d "${pacstrap_dir}/var/log" ]] && find "${pacstrap_dir}/var/log" -type f -delete
    # Delete all temporary files and dirs
    [[ -d "${pacstrap_dir}/var/tmp" ]] && find "${pacstrap_dir}/var/tmp" -mindepth 1 -delete
    # Delete package pacman related files.
    find "${work_dir}" \( -name '*.pacnew' -o -name '*.pacsave' -o -name '*.pacorig' \) -delete
    # Create an empty /etc/machine-id
    rm -f -- "${pacstrap_dir}/etc/machine-id"
    printf '' > "${pacstrap_dir}/etc/machine-id"

    _msg_info "Done!"
}

# Create a squashfs image and place it in the ISO 9660 file system.
# $@: options to pass to mksquashfs
_run_mksquashfs() {
    # Set default mksquashfs options
    local mksquashfs_options=() image_path="${isofs_dir}/${install_dir}/${arch}/airootfs.sfs"
    rm -f -- "${image_path}"
    [[ ! "${quiet}" == "y" ]] || mksquashfs_options+=('-no-progress' '-quiet')
    mksquashfs "$@" "${image_path}" -noappend "${airootfs_image_tool_options[@]}" "${mksquashfs_options[@]}"
}

# Create an ext4 image containing the root file system and pack it inside a squashfs image.
# Save the squashfs image on the ISO 9660 file system.
_mkairootfs_ext4+squashfs() {
    local ext4_hash_seed mkfs_ext4_options=()
    [[ -e "${pacstrap_dir}" ]] || _msg_error "The path '${pacstrap_dir}' does not exist" 1

    _msg_info "Creating ext4 image of 32 GiB and copying '${pacstrap_dir}/' to it..."

    ext4_hash_seed="$(uuidgen --sha1 --namespace 93a870ff-8565-4cf3-a67b-f47299271a96 \
        --name "${SOURCE_DATE_EPOCH} ext4 hash seed")"
    mkfs_ext4_options=(
        '-d' "${pacstrap_dir}"
        '-O' '^has_journal,^resize_inode'
        '-E' "lazy_itable_init=0,root_owner=0:0,hash_seed=${ext4_hash_seed}"
        '-m' '0'
        '-F'
        '-U' 'clear'
    )
    [[ ! "${quiet}" == "y" ]] || mkfs_ext4_options+=('-q')
    rm -f -- "${pacstrap_dir}.img"
    E2FSPROGS_FAKE_TIME="${SOURCE_DATE_EPOCH}" mkfs.ext4 "${mkfs_ext4_options[@]}" -- "${pacstrap_dir}.img" 32G
    tune2fs -c 0 -i 0 -- "${pacstrap_dir}.img" > /dev/null
    _msg_info "Done!"

    install -d -m 0755 -- "${isofs_dir}/${install_dir}/${arch}"
    echo
    _msg_info "Creating SquashFS image, this may take some time..."
    _run_mksquashfs "${pacstrap_dir}.img"
    _msg_info "Done!"
    rm -- "${pacstrap_dir}.img"
}

# Create a squashfs image containing the root file system and saves it on the ISO 9660 file system.
_mkairootfs_squashfs() {
    if [[ ! -e "${pacstrap_dir}" ]]; then
        _msg_error "The path '${pacstrap_dir}' does not exist" 1
    fi

    install -d -m 0755 -- "${isofs_dir}/${install_dir}/${arch}"
    echo
    _msg_info "Creating SquashFS image, this may take some time..."
    _run_mksquashfs "${pacstrap_dir}"
    _msg_info "Done!"
}

# Create an EROFS image containing the root file system and saves it on the ISO 9660 file system.
_mkairootfs_erofs() {
    local fsuuid mkfs_erofs_options=()
    [[ -e "${pacstrap_dir}" ]] || _msg_error "The path '${pacstrap_dir}' does not exist" 1

    install -d -m 0755 -- "${isofs_dir}/${install_dir}/${arch}"
    local image_path="${isofs_dir}/${install_dir}/${arch}/airootfs.erofs"
    rm -f -- "${image_path}"
    [[ ! "${quiet}" == "y" ]] || mkfs_erofs_options+=('--quiet')
    # Generate reproducible file system UUID from SOURCE_DATE_EPOCH
    fsuuid="$(uuidgen --sha1 --namespace 93a870ff-8565-4cf3-a67b-f47299271a96 --name "${SOURCE_DATE_EPOCH}")"
    mkfs_erofs_options+=('-U' "${fsuuid}" "${airootfs_image_tool_options[@]}")
    _msg_info "Creating EROFS image, this may take some time..."
    mkfs.erofs "${mkfs_erofs_options[@]}" -- "${image_path}" "${pacstrap_dir}"
    _msg_info "Done!"
}

# Create checksum file for the rootfs image.
_mkchecksum() {
    _msg_info "Creating checksum file for self-test..."
    cd -- "${isofs_dir}/${install_dir}/${arch}"
    if [[ -e "${isofs_dir}/${install_dir}/${arch}/airootfs.sfs" ]]; then
        sha512sum airootfs.sfs > airootfs.sha512
    elif [[ -e "${isofs_dir}/${install_dir}/${arch}/airootfs.erofs" ]]; then
        sha512sum airootfs.erofs > airootfs.sha512
    fi
    cd -- "${OLDPWD}"
    _msg_info "Done!"
}

# GPG sign the root file system image.
_mksignature() {
    local airootfs_image_filename gpg_options=()
    _msg_info "Signing rootfs image..."
    if [[ -e "${isofs_dir}/${install_dir}/${arch}/airootfs.sfs" ]]; then
        airootfs_image_filename="${isofs_dir}/${install_dir}/${arch}/airootfs.sfs"
    elif [[ -e "${isofs_dir}/${install_dir}/${arch}/airootfs.erofs" ]]; then
        airootfs_image_filename="${isofs_dir}/${install_dir}/${arch}/airootfs.erofs"
    fi
    rm -f -- "${airootfs_image_filename}.sig"
    # Add gpg sender option if the value is provided
        [[ -z "${gpg_sender}" ]] || gpg_options+=('--sender' "${gpg_sender}")
    # always use the .sig file extension, as that is what mkinitcpio-archiso's hooks expect
    gpg --batch --no-armor --no-include-key-block --output "${airootfs_image_filename}.sig" --detach-sign \
        --default-key "${gpg_key}" "${gpg_options[@]}" "${airootfs_image_filename}"
    _msg_info "Done!"
}

_mkchecksum_iso() {
    _msg_info "Creating iso image checksum file..."
    cd -- "${out_dir}"
    sha512sum "${image_name}" > "${image_name}.sha512"
    cd -- "${OLDPWD}"
    _msg_info "Done!"
}

_mksignature_iso() {
    _msg_info "Signing iso image..."
    cd -- "${out_dir}"
    gpg --detach-sign --default-key "${gpg_key}" "${image_name}"
    cd -- "${OLDPWD}"
    _msg_info "Done!"
}

# Helper function to run functions only one time.
# $1: function name
_run_once() {
    if [[ ! -e "${work_dir}/${run_once_mode}.${1}" ]]; then
        "$1"
        touch "${work_dir}/${run_once_mode}.${1}"
    fi
}

# Set up custom pacman.conf with custom cache and pacman hook directories.
_make_pacman_conf() {
    local _cache_dirs _system_cache_dirs _profile_cache_dirs
    _system_cache_dirs="$(pacman-conf CacheDir| tr '\n' ' ')"
    _profile_cache_dirs="$(pacman-conf --config "${pacman_conf}" CacheDir| tr '\n' ' ')"

    # Only use the profile's CacheDir, if it is not the default and not the same as the system cache dir.
    if [[ "${_profile_cache_dirs}" != "/var/cache/pacman/pkg" ]] && \
        [[ "${_system_cache_dirs}" != "${_profile_cache_dirs}" ]]; then
        _cache_dirs="${_profile_cache_dirs}"
    else
        _cache_dirs="${_system_cache_dirs}"
    fi

    echo
    _msg_info "Copying custom pacman.conf to work directory..."
    # take the profile pacman.conf and strip all settings that would break in chroot when using pacman -r
    # see `man 8 pacman` for further info
    pacman-conf --config "${pacman_conf}" | \
        sed '/CacheDir/d;/DBPath/d;/HookDir/d;/LogFile/d;/RootDir/d' > "${work_dir}/${buildmode}.pacman.conf"
    _msg_info "Done!"

    _msg_info "Using pacman CacheDir: ${_cache_dirs}"
    # append CacheDir and HookDir to [options] section
    # HookDir is *always* set to the airootfs' override directory
    sed "/\[options\]/a CacheDir = ${_cache_dirs}
        /\[options\]/a HookDir = ${pacstrap_dir}/etc/pacman.d/hooks/" \
        -i "${work_dir}/${buildmode}.pacman.conf"
    _msg_info "Done!"
}

# Set up custom pacman-testing.conf with custom cache and pacman hook directories.
_make_pacman_testing_conf() {
    local _cache_dirs _system_cache_dirs _profile_cache_dirs
    _system_cache_dirs="$(pacman-conf CacheDir| tr '\n' ' ')"
    _profile_cache_dirs="$(pacman-conf --config "${pacman_testing_conf}" CacheDir| tr '\n' ' ')"

    # only use the profile's CacheDir, if it is not the default and not the same as the system cache dir
    if [[ "${_profile_cache_dirs}" != "/var/cache/pacman/pkg" ]] && \
        [[ "${_system_cache_dirs}" != "${_profile_cache_dirs}" ]]; then
        _cache_dirs="${_profile_cache_dirs}"
    else
        _cache_dirs="${_system_cache_dirs}"
    fi

    _msg_info "Copying custom pacman-testing.conf to work directory..."
    # take the profile pacman-testing.conf and strip all settings that would break in chroot when using pacman -r
    # see `man 8 pacman` for further info
    pacman-conf --config "${pacman_testing_conf}" | \
        sed '/CacheDir/d;/DBPath/d;/HookDir/d;/LogFile/d;/RootDir/d' > "${work_dir}/pacman-testing.conf"
    _msg_info "Done!"

    _msg_info "Using pacman CacheDir: ${_cache_dirs}"
    # append CacheDir and HookDir to [options] section
    # HookDir is *always* set to the airootfs' override directory
    sed "/\[options\]/a CacheDir = ${_cache_dirs}
        /\[options\]/a HookDir = ${pacstrap_dir}/etc/pacman.d/hooks/" \
        -i "${work_dir}/pacman-testing.conf"
    _msg_info "Done!"
}

# Prepare working directory and copy custom root file system files.
_make_custom_airootfs() {
    local passwd=()
    local filename permissions

    install -d -m 0755 -o 0 -g 0 -- "${pacstrap_dir}"

    if [[ -d "${profile}/airootfs" ]]; then
        _msg_info "Copying custom airootfs files..."
        cp -af --no-preserve=ownership -- "${profile}/airootfs/." "${pacstrap_dir}"
        # airootfs localization
        if [[ -n "${lang}" ]]; then
            cp -af --no-preserve=ownership -- "${profile}/lang/${lang}/airootfs/." "${pacstrap_dir}"
        fi
        # Set ownership and mode for files and directories
        for filename in "${!file_permissions[@]}"; do
            IFS=':' read -ra permissions <<< "${file_permissions["${filename}"]}"
            # Prevent file path traversal outside of $pacstrap_dir
            if [[ "$(realpath -q -- "${pacstrap_dir}${filename}")" != "${pacstrap_dir}"* ]]; then
                _msg_error "Failed to set permissions on '${pacstrap_dir}${filename}'. Outside of valid path." 1
            # Warn if the file does not exist
            elif [[ ! -e "${pacstrap_dir}${filename}" ]]; then
                _msg_warning "Cannot change permissions of '${pacstrap_dir}${filename}'. The file or directory does not exist."
            else
                if [[ "${filename: -1}" == "/" ]]; then
                    chown -fhR -- "${permissions[0]}:${permissions[1]}" "${pacstrap_dir}${filename}"
                    chmod -fR -- "${permissions[2]}" "${pacstrap_dir}${filename}"
                else
                    chown -fh -- "${permissions[0]}:${permissions[1]}" "${pacstrap_dir}${filename}"
                    chmod -f -- "${permissions[2]}" "${pacstrap_dir}${filename}"
                fi
            fi
        done
    fi

    # Set archiso cow_spacesize to 50% ram size
    sed -i 's|\(cow_spacesize=\)"256M"|\1"$(( $(awk \x27/MemTotal:/ { print $2 }\x27 /proc/meminfo) / 2 / 1024 ))M"|' \
        "${work_dir}/x86_64/airootfs/etc/initcpio/hooks/archiso"
    _msg_info "Done!"
}

# Install desired packages to the root file system
_make_packages() {
     _msg_info "Installing packages to '${pacstrap_dir}/'..."

    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<>"${work_dir}/pubkey.gpg"
        export ARCHISO_GNUPG_FD
    fi

    # Unset TMPDIR to work around https://bugs.archlinux.org/task/70580
    if [[ "${quiet}" = "y" ]]; then
        env -u TMPDIR \
        pacstrap -C "${work_dir}/${buildmode}.pacman.conf" -c -G -M -- "${pacstrap_dir}" "${buildmode_pkg_list[@]}" &> /dev/null
    else
        env -u TMPDIR \
        pacstrap -C "${work_dir}/${buildmode}.pacman.conf" -c -G -M -- "${pacstrap_dir}" "${buildmode_pkg_list[@]}"
    fi

    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<&-
        unset ARCHISO_GNUPG_FD
    fi

    _msg_info "Done!"
}

# Packages in testing (airootfs)
_make_packages_testing() {
    _msg_info "Installing testing packages to '${pacstrap_dir}/'..."

    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<>"${work_dir}/pubkey.gpg"
        export ARCHISO_GNUPG_FD
    fi

    if [[ "${quiet}" = "y" ]]; then
        pacstrap -C "${work_dir}/pacman-testing.conf" -c -G -M -- "${pacstrap_dir}" "${pkg_testing_list[@]}" &> /dev/null
    else
        pacstrap -C "${work_dir}/pacman-testing.conf" -c -G -M -- "${pacstrap_dir}" "${pkg_testing_list[@]}"
    fi

    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<&-
        unset ARCHISO_GNUPG_FD
    fi

    _msg_info "Done!"
}

_umount_chroot-dir() {
    if findmnt -nr -- "${pacstrap_dir}" > /dev/null; then
        umount "${pacstrap_dir}"
    fi
}

# airootfs install user provided packages
_make_packages_upgrade() {
    trap "_umount_chroot-dir" EXIT HUP INT TERM
    local _pkg_upgrade
    mapfile -t _pkg_upgrade < <(find "${user_pkg_dir}" -maxdepth 1 \( -name "*.pkg.tar.xz" -o -name "*.pkg.tar.zst" \))

    _msg_info "Installing user packages to '${pacstrap_dir}/'..."

    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<>"${work_dir}/pubkey.gpg"
        export ARCHISO_GNUPG_FD
    fi

    # bind mount chroot-dir on itself to make it a mountpoint
    mount -o bind -- "${pacstrap_dir}" "${pacstrap_dir}"
    if [[ "${quiet}" = "y" ]]; then
        pacstrap -C "${work_dir}/${buildmode}.pacman.conf" -c -G -M -U -- "${pacstrap_dir}" "${_pkg_upgrade[@]}" &> /dev/null
    else
        pacstrap -C "${work_dir}/${buildmode}.pacman.conf" -c -G -M -U -- "${pacstrap_dir}" "${_pkg_upgrade[@]}"
    fi
    umount "${pacstrap_dir}"

    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<&-
        unset ARCHISO_GNUPG_FD
    fi

    _msg_info "Done!"
}

# Customize installation.
_make_customize_airootfs() {
    local passwd=()

    # Set up user home directories and permissions
    if [[ -e "${profile}/airootfs/etc/passwd" ]]; then
        _msg_info "Copying /etc/skel/* to user homes..."
        while IFS=':' read -a passwd -r; do
            # Only operate on UIDs in range 1000â€“59999
            (( passwd[2] >= 1000 && passwd[2] < 60000 )) || continue
            # Skip invalid home directories
            [[ "${passwd[5]}" == '/' ]] && continue
	        [[ -z "${passwd[5]}" ]] && continue
            # Prevent path traversal outside of $pacstrap_dir
            if [[ "$(realpath -q -- "${pacstrap_dir}${passwd[5]}")" == "${pacstrap_dir}"* ]]; then
                if [[ ! -d "${pacstrap_dir}${passwd[5]}" ]]; then
                    install -d -m 0750 -o "${passwd[2]}" -g "${passwd[3]}" -- "${pacstrap_dir}${passwd[5]}"
                fi
                cp -dnRT --preserve=mode,timestamps,links -- "${pacstrap_dir}/etc/skel/." "${pacstrap_dir}${passwd[5]}"
                chown -hR -- "${passwd[2]}:${passwd[3]}" "${pacstrap_dir}${passwd[5]}"
            else
                _msg_error "Failed to set permissions on '${pacstrap_dir}${passwd[5]}'. Outside of valid path." 1
            fi
        done < "${profile}/airootfs/etc/passwd" 
        _msg_info "Done!"
    fi

    if [[ -e "${pacstrap_dir}/root/customize_airootfs_lang.sh" ]]; then
        _msg_info "Running customize_airootfs_lang.sh in '${pacstrap_dir}' chroot..."
        chmod -f -- +x "${pacstrap_dir}/root/customize_airootfs_lang.sh"
        # Unset TMPDIR to work around https://bugs.archlinux.org/task/70580
        if [[ "${quiet}" == "y" ]]; then
            eval -- env -u TMPDIR arch-chroot "${pacstrap_dir}" "/root/customize_airootfs_lang.sh"  &> /dev/null
        else
            eval -- env -u TMPDIR arch-chroot "${pacstrap_dir}" "/root/customize_airootfs_lang.sh"
        fi
        rm -- "${pacstrap_dir}/root/customize_airootfs_lang.sh"
        _msg_info "Done!"
    fi
    if [[ -e "${pacstrap_dir}/root/customize_airootfs.sh" ]]; then
        _msg_info "Running customize_airootfs.sh in '${pacstrap_dir}' chroot..."
        chmod -f -- +x "${pacstrap_dir}/root/customize_airootfs.sh"
        if [[ "${quiet}" == "y" ]]; then
            eval -- env -i "SOURCE_DATE_EPOCH=${SOURCE_DATE_EPOCH}" \
                    arch-chroot "${pacstrap_dir}" "/root/customize_airootfs.sh" &> /dev/null
        else
            eval -- env -i "SOURCE_DATE_EPOCH=${SOURCE_DATE_EPOCH}" \
                    arch-chroot "${pacstrap_dir}" "/root/customize_airootfs.sh"
        fi
        rm -- "${pacstrap_dir}/root/customize_airootfs.sh"
        _msg_info "Done!"
    fi
}

# rebuild initramfs (airootfs)
_make_setup_mkinitcpio() {
    if [[ "${iso_version}" =~ (nvidia|optimus) ]]; then
        # add nvidia modules to initramfs
        sed -i 's/MODULES=(/&nvidia nvidia_drm nvidia_modeset/' "${pacstrap_dir}/etc/mkinitcpio.conf"
    fi
    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<>"${work_dir}/pubkey.gpg"
        export ARCHISO_GNUPG_FD
    fi

    if [[ "${quiet}" = "y" ]]; then
        arch-chroot "${pacstrap_dir}" mkinitcpio -P &> /dev/null
    else
        arch-chroot "${pacstrap_dir}" mkinitcpio -P
    fi

    if [[ -n "${gpg_key}" ]]; then
        exec {ARCHISO_GNUPG_FD}<&-
        unset ARCHISO_GNUPG_FD
    fi
}

# Set up boot loaders
_make_bootmodes() {
    local bootmode
    for bootmode in "${bootmodes[@]}"; do
        _run_once "_make_bootmode_${bootmode}"
    done
}

# Copy kernel and initramfs to ISO 9660
_make_boot_on_iso9660() {
    _msg_info "Preparing kernel and initramfs for the ISO 9660 file system..."
    install -d -m 0755 -- "${isofs_dir}/${install_dir}/boot/${arch}"
    install -m 0644 -- "${pacstrap_dir}/boot/initramfs-"*".img" "${isofs_dir}/${install_dir}/boot/${arch}/"
    install -m 0644 -- "${pacstrap_dir}/boot/vmlinuz-"* "${isofs_dir}/${install_dir}/boot/${arch}/"

    for _ucode_image in "${ucodes[@]}"; do
        if [[ -e "${pacstrap_dir}/boot/${_ucode_image}" ]]; then
            install -m 0644 -- "${pacstrap_dir}/boot/${_ucode_image}" "${isofs_dir}/${install_dir}/boot/"
            if [[ -e "${pacstrap_dir}/usr/share/licenses/${_ucode_image%.*}/" ]]; then
                install -d -m 0755 -- "${isofs_dir}/${install_dir}/boot/licenses/${_ucode_image%.*}/"
                install -m 0644 -- "${pacstrap_dir}/usr/share/licenses/${_ucode_image%.*}/"* \
                    "${isofs_dir}/${install_dir}/boot/licenses/${_ucode_image%.*}/"
            fi
        fi
    done
    _msg_info "Done!"
}

# Prepare syslinux for booting from MBR (isohybrid)
_make_bootmode_bios.syslinux.mbr() {
    _msg_info "Setting up SYSLINUX for BIOS booting from a disk..."
    install -d -m 0755 -- "${isofs_dir}/syslinux"
    for _cfg in "${profile}/syslinux/"*.cfg; do
        sed "s|%DESKTOP%|${desktop}|g;
             s|%ARCHISO_LABEL%|${iso_label}|g;
             s|%INSTALL_DIR%|${install_dir}|g;
             s|%ARCH%|${arch}|g" \
             "${_cfg}" > "${isofs_dir}/syslinux/${_cfg##*/}"
    done
    if [[ -e "${profile}/syslinux/splash.png" ]]; then
        install -m 0644 -- "${profile}/syslinux/splash.png" "${isofs_dir}/syslinux/"
    fi
    install -m 0644 -- "${work_dir}/x86_64/airootfs/usr/lib/syslinux/bios/"*.c32 "${isofs_dir}/syslinux/"
    install -m 0644 -- "${work_dir}/x86_64/airootfs/usr/lib/syslinux/bios/lpxelinux.0" "${isofs_dir}/syslinux/"
    install -m 0644 -- "${work_dir}/x86_64/airootfs/usr/lib/syslinux/bios/memdisk" "${isofs_dir}/syslinux/"

    _run_once _make_boot_on_iso9660

    if [[ -e "${isofs_dir}/syslinux/hdt.c32" ]]; then
        install -d -m 0755 -- "${isofs_dir}/syslinux/hdt"
        if [[ -e "${pacstrap_dir}/usr/share/hwdata/pci.ids" ]]; then
            gzip -cn9 "${pacstrap_dir}/usr/share/hwdata/pci.ids" > \
                "${isofs_dir}/syslinux/hdt/pciids.gz"
        fi
        find "${pacstrap_dir}/usr/lib/modules" -name 'modules.alias' -print -exec gzip -cn9 '{}' ';' -quit > \
            "${isofs_dir}/syslinux/hdt/modalias.gz"
    fi

    # Add other aditional/extra files to ${install_dir}/boot/
    if [[ -e "${pacstrap_dir}/boot/memtest86+/memtest.bin" ]]; then
        # rename for PXE: https://wiki.archlinux.org/title/Syslinux#Using_memtest
        install -m 0644 -- "${pacstrap_dir}/boot/memtest86+/memtest.bin" "${isofs_dir}/${install_dir}/boot/memtest"
        install -d -m 0755 -- "${isofs_dir}/${install_dir}/boot/licenses/memtest86+/" 
        install -m 0644 -- "${pacstrap_dir}/usr/share/licenses/common/GPL2/license.txt" \
            "${isofs_dir}/${install_dir}/boot/licenses/memtest86+/"
    fi
    _msg_info "Done!"
}

# Prepare syslinux for El-Torito booting
_make_bootmode_bios.syslinux.eltorito() {
    _msg_info "Setting up SYSLINUX for BIOS booting from an optical disc..."
    install -d -m 0755 -- "${isofs_dir}/syslinux"
    install -m 0644 -- "${pacstrap_dir}/usr/lib/syslinux/bios/isolinux.bin" "${isofs_dir}/syslinux/"
    install -m 0644 -- "${pacstrap_dir}/usr/lib/syslinux/bios/isohdpfx.bin" "${isofs_dir}/syslinux/"

    # ISOLINUX and SYSLINUX installation is shared
    _run_once _make_bootmode_bios.syslinux.mbr

    _msg_info "Done!"
}

# Copy kernel and initramfs to FAT image
_make_boot_on_fat() {
    local -a _all_ucode_images=()
    _msg_info "Preparing kernel and initramfs for the FAT file system..."
    mmd -i "${work_dir}/efiboot.img" \
        "::/${install_dir}" "::/${install_dir}/boot" "::/${install_dir}/boot/${arch}"
    mcopy -i "${work_dir}/efiboot.img" "${pacstrap_dir}/boot/vmlinuz-"* \
        "${pacstrap_dir}/boot/initramfs-"*".img" "::/${install_dir}/boot/${arch}/"
    for _ucode_image in "${ucodes[@]}"; do
        if [[ -e "${pacstrap_dir}/boot/${_ucode_image}" ]]; then
            _all_ucode_images+=("${pacstrap_dir}/boot/${_ucode_image}")
        fi
    done
    if (( ${#_all_ucode_images[@]} )); then
        mcopy -i "${work_dir}/efiboot.img" "${_all_ucode_images[@]}" "::/${install_dir}/boot/"
    fi
    _msg_info "Done!"
}

# Create a FAT image (efiboot.img) which will serve as the EFI system partition
# $1: image size in bytes
_make_efibootimg() {
    local _imgsize="0"

    # Convert from bytes to KiB and round up to the next full MiB with an additional MiB for reserved sectors.
    _imgsize="$(awk 'function ceil(x){return int(x)+(x>int(x))}
            function byte_to_kib(x){return x/1024}
            function mib_to_kib(x){return x*1024}
            END {print mib_to_kib(ceil((byte_to_kib($1)+1024)/1024))}' <<< "${1}"
    )"
    # The FAT image must be created with mkfs.fat not mformat, as some systems have issues with mformat made images:
    # https://lists.gnu.org/archive/html/grub-devel/2019-04/msg00099.html
    rm -f -- "${work_dir}/efiboot.img"
    _msg_info "Creating FAT image of size: ${_imgsize} KiB..."
    if [[ "${quiet}" == "y" ]]; then
        # mkfs.fat does not have a -q/--quiet option, so redirect stdout to /dev/null instead
        # https://github.com/dosfstools/dosfstools/issues/103
        mkfs.fat -C -n LIVEMEDIUM "${work_dir}/efiboot.img" "${_imgsize}" &> /dev/null
    else
        mkfs.fat -C -n LIVEMEDIUM "${work_dir}/efiboot.img" "${_imgsize}"
    fi
    _msg_info "Done!"

    # Create the default/fallback boot path in which a boot loaders will be placed later.
    mmd -i "${work_dir}/efiboot.img" \
           ::/EFI ::/EFI/BOOT ::/EFI/BOOT/drivers_x64 ::/EFI/BOOT/icons ::/EFI/live \
           ::/loader ::/loader/entries
}

# Prepare system-boot for booting when written to a disk (isohybrid)
_make_bootmode_uefi-x64.systemd-boot.esp() {
    local _file _efiboot_imgsize
    local _available_ucodes=()
    _msg_info "Setting up systemd-boot for UEFI booting..."

    for _file in "${ucodes[@]}"; do
        if [[ -e "${pacstrap_dir}/boot/${_file}" ]]; then
            _available_ucodes+=("${pacstrap_dir}/boot/${_file}")
        fi
    done
    # Calculate the required FAT image size in bytes
    _efiboot_imgsize="$(du -bc \
        "${pacstrap_dir}/usr/lib/systemd/boot/efi/systemd-bootx64.efi" \
        "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" \
        "${profile}/efiboot/" \
        "${pacstrap_dir}/boot/vmlinuz-"* \
        "${pacstrap_dir}/boot/initramfs-"*".img" \
        "${_available_ucodes[@]}" \
        "${pacstrap_dir}/usr/share/refind" \
        2>/dev/null | awk 'END { print $1 }')"
    # Create a FAT image for the EFI system partition
    _make_efibootimg "${_efiboot_imgsize}"

    # Copy rEFInd files and systemd-boot EFI binary to the different boot paths
    mcopy -i "${work_dir}/efiboot.img" \
             "${work_dir}/x86_64/airootfs/usr/share/refind/refind_x64.efi" ::/EFI/BOOT/BOOTx64.EFI
    mcopy -i "${work_dir}/efiboot.img" \
             "${work_dir}"/x86_64/airootfs/usr/share/refind/drivers_x64/* ::/EFI/BOOT/drivers_x64/
    mcopy -i "${work_dir}/efiboot.img" \
             "${work_dir}"/x86_64/airootfs/usr/share/refind/icons/* ::/EFI/BOOT/icons/
    mcopy -i "${work_dir}/efiboot.img" \
             "${work_dir}/x86_64/airootfs/usr/lib/systemd/boot/efi/systemd-bootx64.efi" ::/EFI/live/livedvd.efi
    mcopy -i "${work_dir}/efiboot.img" \
             "${work_dir}/x86_64/airootfs/usr/share/refind/icons/os_arch.png" ::/EFI/live/livedvd.png
    mcopy -i "${work_dir}/efiboot.img" \
             "${profile}/efiboot/boot/refind-dvd.conf" ::/EFI/BOOT/refind.conf

    # Copy systemd-boot configuration files
    mcopy -i "${work_dir}/efiboot.img" \
             "${profile}/efiboot/loader/loader.conf" ::loader/

    for _conf in "${profile}/efiboot/loader/entries/"*".conf"; do
        sed "s|%DESKTOP%|${desktop}|g;
             s|%ARCHISO_LABEL%|${iso_label}|g;
             s|%INSTALL_DIR%|${install_dir}|g;
             s|%ARCH%|${arch}|g" \
             "${_conf}" | mcopy -i "${work_dir}/efiboot.img" - "::/loader/entries/${_conf##*/}"
    done

    # shellx64.efi is picked up automatically when on /
    if [[ -e "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" ]]; then
        mcopy -i "${work_dir}/efiboot.img" \
            "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" ::/shellx64.efi
    fi

    _msg_info "Done!"

    # Copy kernel and initramfs to FAT image.
    # systemd-boot can only access files from the EFI system partition it was launched from.
    _make_boot_on_fat
}

# Prepare system-boot for El Torito booting
_make_bootmode_uefi-x64.systemd-boot.eltorito() {
    # El Torito UEFI boot requires an image containing the EFI system partition.
    # uefi-x64.systemd-boot.eltorito has the same requirements as uefi-x64.systemd-boot.esp
    _run_once _make_bootmode_uefi-x64.systemd-boot.esp
    # Additionally set up system-boot in ISO 9660. This allows creating a medium for the live environment by using
    # manual partitioning and simply copying the ISO 9660 file system contents.
    # This is not related to El Torito booting and no firmware uses these files.
    _msg_info "Preparing an /EFI directory for the ISO 9660 file system..."
    install -d -m 0755 -- "${isofs_dir}/EFI/BOOT"
    install -d -m 0755 -- "${isofs_dir}/EFI/live"

    # Copy rEFInd files and systemd-boot EFI binary to the different boot paths
    install -m 0644 -- "${work_dir}/x86_64/airootfs/usr/share/refind/refind_x64.efi" "${isofs_dir}/EFI/BOOT/BOOTx64.efi"
    cp -a -- "${work_dir}"/x86_64/airootfs/usr/share/refind/{drivers_x64,icons}/ "${isofs_dir}/EFI/BOOT/"

    install -m 0644 -- "${work_dir}/x86_64/airootfs/usr/lib/systemd/boot/efi/systemd-bootx64.efi" "${isofs_dir}/EFI/live/livedisk.efi"
    install -m 0644 -- "${work_dir}/x86_64/airootfs/usr/share/refind/icons/os_arch.png" "${isofs_dir}/EFI/live/livedisk.png"

    install -m 0644 -- "${profile}/efiboot/boot/refind-usb.conf" "${isofs_dir}/EFI/BOOT/refind.conf"

    # Copy systemd-boot configuration files
    install -d -m 0755 -- "${isofs_dir}/loader/entries"
    install -m 0644 -- "${profile}/efiboot/loader/loader.conf" "${isofs_dir}/loader/"
    for _entry in  "${profile}/efiboot/loader/entries/"*".conf"; do
        install -m 0644 -- "${_entry}" "${isofs_dir}/loader/entries/${_entry##*/}"
    done

    for _conf in "${profile}/efiboot/loader/entries/"*".conf"; do
        sed "s|%DESKTOP%|${desktop}|g;
             s|%ARCHISO_LABEL%|${iso_label}|g;
             s|%INSTALL_DIR%|${install_dir}|g;
             s|%ARCH%|${arch}|g" \
             "${_conf}" > "${isofs_dir}/loader/entries/${_conf##*/}"
    done

    # edk2-shell based UEFI shell
    # shellx64.efi is picked up automatically when on /
    if [[ -e "${pacstrap_dir}/usr/share/edk2-shell/x64/Shell_Full.efi" ]]; then
        install -m 0644 -- "${work_dir}/x86_64/airootfs/usr/share/edk2-shell/x64/Shell_Full.efi" "${isofs_dir}/shellx64.efi"
    fi

    _msg_info "Done!"
}

# Archuseriso data
_make_aui() {
    if [[ -z "${image_name}" ]]; then
        image_name="${iso_name}-${iso_version}-x64.iso"
    fi

    cp -aT --no-preserve=ownership -- "${profile}/aui/" "${isofs_dir}/aui/"
    mv -- "${isofs_dir}/aui/liveusb/persistent" "${isofs_dir}/aui/liveusb/persistent_${iso_label}"

    ### esp
    # syslinux
    if [[ -d "${isofs_dir}/syslinux" ]]; then
        install -d -m 0755 -- "${isofs_dir}/aui/liveusb/esp/"
        ln -s -- "../../../syslinux" "${isofs_dir}/aui/liveusb/esp/syslinux"
    fi

    # live kernel & initramfs
    install -d -m 0755 -- "${isofs_dir}/aui/liveusb/esp/${install_dir}/boot/x86_64/"
    install -d -m 0755 -- "${isofs_dir}/aui/liveusb/esp/${install_dir}/boot/licenses/"
    for _ucode_image in {intel-uc.img,intel-ucode.img,amd-uc.img,amd-ucode.img,early_ucode.cpio,microcode.cpio}; do
            if [[ -e "${isofs_dir}/${install_dir}/boot/${_ucode_image}" ]]; then
                ln -s -- "../../../../../${install_dir}/boot/${_ucode_image}" "${isofs_dir}/aui/liveusb/esp/${install_dir}/boot/"
            fi
    done
    if [[ -d "${isofs_dir}/${install_dir}/boot/licenses" ]]; then
        for _license in "${isofs_dir}/${install_dir}/boot/licenses/"*; do
            ln -s -- "../../../../../../${install_dir}/boot/licenses/${_license##*/}/" \
                     "${isofs_dir}/aui/liveusb/esp/${install_dir}/boot/licenses/${_license##*/}"
        done
    fi
    if [[ -f "${isofs_dir}/${install_dir}/boot/memtest" ]]; then
        ln -s -- "../../../../../${install_dir}/boot/memtest" "${isofs_dir}/aui/liveusb/esp/${install_dir}/boot/"
    fi
    for _kernel in "${isofs_dir}/${install_dir}/boot/x86_64/vmlinuz-"* \
                   "${isofs_dir}/${install_dir}/boot/x86_64/initramfs-"*".img"; do
            ln -s -- "../../../../../../${install_dir}/boot/x86_64/${_kernel##*/}" \
                  "${isofs_dir}/aui/liveusb/esp/${install_dir}/boot/x86_64/"
    done

    # persistent kernel & initramfs
    install -d -m 0755 -- "${isofs_dir}/aui/liveusb/esp/EFI/"
    for _ucode_image in {intel-uc.img,intel-ucode.img,amd-uc.img,amd-ucode.img,early_ucode.cpio,microcode.cpio}; do
        if [[ -e "${isofs_dir}/${install_dir}/boot/${_ucode_image}" ]]; then
            ln -s -- "../../../${install_dir}/boot/${_ucode_image}" "${work_dir}/iso/aui/liveusb/esp/"
        fi
    done
    for _kernel in "${isofs_dir}/${install_dir}/boot/x86_64/vmlinuz-"* \
                   "${isofs_dir}/${install_dir}/boot/x86_64/initramfs-"*".img"; do
        ln -s -- "../../../${install_dir}/boot/x86_64/${_kernel##*/}" "${work_dir}/iso/aui/liveusb/esp/"
    done
    [[ -d "${isofs_dir}/loader" ]] && ln -s -- ../../../loader "${isofs_dir}/aui/liveusb/esp/loader"
    [[ -d "${isofs_dir}/EFI/BOOT" ]] && ln -s -- ../../../../EFI/BOOT "${isofs_dir}/aui/liveusb/esp/EFI/BOOT"
    [[ -d "${isofs_dir}/EFI/live" ]] && ln -s -- ../../../../EFI/live "${isofs_dir}/aui/liveusb/esp/EFI/live"
    [[ -d "${isofs_dir}/shellx64.efi" ]] && ln -s -- ../../../shellx64.efi "${isofs_dir}/aui/liveusb/esp/shellx64.efi"

    if [[ -f "${isofs_dir}/aui/mediumdef.sh" ]]; then
        # Set medium def
        sed -i "s|%DESKTOP%|${desktop}|g;
                s|%INSTALL_DIR%|${install_dir}|g;
                s|%ARCHISO_LABEL%|${iso_label}|g;
                s|%ISO_NAME%|${iso_name}|g;
                s|%ISO_VERSION%|${iso_version}|g;
                s|%LANG%|${lang}|g" \
                "${isofs_dir}/aui/mediumdef.sh"
    fi
    for auifile in "${isofs_dir}/aui/liveusb/loader/entries/"*.conf \
                   "${isofs_dir}/aui/hybrid/loader/entries/"*.conf \
                   "${isofs_dir}/aui/liveusb/syslinux/archiso_sys-linux.cfg" \
                   "${isofs_dir}/aui/hybrid/syslinux/archiso_sys-linux.cfg"; do
        if [[ -f "${auifile}" ]]; then
            sed -i "s|%INSTALL_DIR%|${install_dir}|g;
                    s|%DESKTOP%|${desktop}|g" "${auifile}"
        fi
    done
    if [[ -n "${embed_dir}" && -d "${embed_dir}" ]]; then
        cp -aT --no-preserve=ownership "${embed_dir}" "${isofs_dir}/data"
    fi
}

_validate_requirements_bootmode_bios.syslinux.mbr() {
    # bios.syslinux.mbr requires bios.syslinux.eltorito
    # shellcheck disable=SC2076
    if [[ ! " ${bootmodes[*]} " =~ ' bios.syslinux.eltorito ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Using 'bios.syslinux.mbr' boot mode without 'bios.syslinux.eltorito' is not supported." 0
    fi

    # Check if the syslinux package is in the package list
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' syslinux ' ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': The 'syslinux' package is missing from the package list!" 0
    fi

    # Check if syslinux configuration files exist
    if [[ ! -d "${profile}/syslinux" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': The '${profile}/syslinux' directory is missing!" 0
    else
        local cfgfile
        for cfgfile in "${profile}/syslinux/"*'.cfg'; do
            if [[ -e "${cfgfile}" ]]; then
                break
            else
                (( validation_error=validation_error+1 ))
                _msg_error "Validating '${bootmode}': No configuration file found in '${profile}/syslinux/'!" 0
            fi
        done
    fi

    # Check for optional packages
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' memtest86+ ' ]]; then
        _msg_info "Validating '${bootmode}': 'memtest86+' is not in the package list. Memmory testing will not be available from syslinux."
    fi
}

_validate_requirements_bootmode_bios.syslinux.eltorito() {
    # bios.syslinux.eltorito has the exact same requirements as bios.syslinux.mbr
    _validate_requirements_bootmode_bios.syslinux.mbr
}

_validate_requirements_bootmode_uefi-x64.systemd-boot.esp() {
    # Check if mkfs.fat is available
    if ! command -v mkfs.fat &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': mkfs.fat is not available on this host. Install 'dosfstools'!" 0
    fi

    # Check if mmd and mcopy are available
    if ! { command -v mmd &> /dev/null && command -v mcopy &> /dev/null; }; then
        _msg_error "Validating '${bootmode}': mmd and/or mcopy are not available on this host. Install 'mtools'!" 0
    fi

    # Check if systemd-boot configuration files exist
    if [[ ! -d "${profile}/efiboot/loader/entries" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${bootmode}': The '${profile}/efiboot/loader/entries' directory is missing!" 0
    else
        if [[ ! -e "${profile}/efiboot/loader/loader.conf" ]]; then
            (( validation_error=validation_error+1 ))
            _msg_error "Validating '${bootmode}': File '${profile}/efiboot/loader/loader.conf' not found!" 0
        fi
        local conffile
        for conffile in "${profile}/efiboot/loader/entries/"*'.conf'; do
            if [[ -e "${conffile}" ]]; then
                break
            else
                (( validation_error=validation_error+1 ))
                _msg_error "Validating '${bootmode}': No configuration file found in '${profile}/efiboot/loader/entries/'!" 0
            fi
        done
    fi

    # Check for optional packages
    # shellcheck disable=SC2076
    if [[ ! " ${pkg_list[*]} " =~ ' edk2-shell ' ]]; then
        _msg_info "'edk2-shell' is not in the package list. The ISO will not contain a bootable UEFI shell."
    fi
}

_validate_requirements_bootmode_uefi-x64.systemd-boot.eltorito() {
    # uefi-x64.systemd-boot.eltorito has the exact same requirements as uefi-x64.systemd-boot.esp
    _validate_requirements_bootmode_uefi-x64.systemd-boot.esp
}

# Build airootfs filesystem image
_prepare_airootfs_image() {
    _run_once "_mkairootfs_${airootfs_image_type}"
    _mkchecksum
    if [[ -n "${gpg_key}" ]]; then
        _mksignature
    fi
}

# export build artifacts for netboot
_export_netboot_artifacts() {
    _msg_info "Exporting netboot artifacts..."
    install -d -m 0755 "${out_dir}"
    cp -a -- "${isofs_dir}/${install_dir}/" "${out_dir}/"
    _msg_info "Done!"
    du -hs -- "${out_dir}/${install_dir}"
}

# sign build artifacts for netboot
_sign_netboot_artifacts() {
    local _file _dir
    local _files_to_sign=()
    _msg_info "Signing netboot artifacts..."
    _dir="${isofs_dir}/${install_dir}/boot/"
    for _file in "${ucodes[@]}"; do
        if [[ -e "${_dir}${_file}" ]]; then
            _files_to_sign+=("${_dir}${_file}")
        fi
    done
    for _file in "${_files_to_sign[@]}" "${_dir}${arch}/vmlinuz-"* "${_dir}${arch}/initramfs-"*.img; do
        openssl cms \
            -sign \
            -binary \
            -noattr \
            -in "${_file}" \
            -signer "${cert_list[0]}" \
            -inkey "${cert_list[1]}" \
            -outform DER \
            -out "${_file}".ipxe.sig
    done
    _msg_info "Done!"
}

_validate_requirements_airootfs_image_type_squashfs() {
    if ! command -v mksquashfs &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${airootfs_image_type}': mksquashfs is not available on this host. Install 'squashfs-tools'!" 0
    fi
}

_validate_requirements_airootfs_image_type_ext4+squashfs() {
    if ! { command -v mkfs.ext4 &> /dev/null && command -v tune2fs &> /dev/null; }; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${airootfs_image_type}': mkfs.ext4 and/or tune2fs is not available on this host. Install 'e2fsprogs'!" 0
    fi
    _validate_requirements_airootfs_image_type_squashfs
}

_validate_requirements_airootfs_image_type_erofs() {
    if ! command -v mkfs.erofs &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating '${airootfs_image_type}': mkfs.erofs is not available on this host. Install 'erofs-utils'!" 0
    fi
}

_validate_common_requirements_buildmode_all() {
    if ! command -v pacman &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': pacman is not available on this host. Install 'pacman'!" 0
    fi
    if ! command -v find &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': find is not available on this host. Install 'findutils'!" 0
    fi
    if ! command -v gzip &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': gzip is not available on this host. Install 'gzip'!" 0
    fi
}

_validate_requirements_buildmode_bootstrap() {
    local bootstrap_pkg_list_from_file=()

    # Check if packages for the bootstrap image are specified
    if [[ -e "${bootstrap_packages}" ]]; then
        mapfile -t bootstrap_pkg_list_from_file < \
            <(sed '/^[[:blank:]]*#.*/d;s/#.*//;/^[[:blank:]]*$/d' "${bootstrap_packages}")
        bootstrap_pkg_list+=("${bootstrap_pkg_list_from_file[@]}")
        if (( ${#bootstrap_pkg_list_from_file[@]} < 1 )); then
            (( validation_error=validation_error+1 ))
            _msg_error "No package specified in '${bootstrap_packages}'." 0
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg_error "Bootstrap packages file '${bootstrap_packages}' does not exist." 0
    fi

    _validate_common_requirements_buildmode_all
    if ! command -v bsdtar &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': bsdtar is not available on this host. Install 'libarchive'!" 0
    fi
}

_validate_common_requirements_buildmode_iso_netboot() {
    local bootmode
    local pkg_list_from_file=()

    # Check if the package list file exists and read packages from it
    if [[ -e "${packages}" ]]; then
        mapfile -t pkg_list_from_file < <(sed '/^[[:blank:]]*#.*/d;s/#.*//;/^[[:blank:]]*$/d;s/[[:blank:]]/\n/g' "${packages}" "${packages_locales:-/dev/null}" | sed '/^$/d')
        pkg_list+=("${pkg_list_from_file[@]}")
        if (( ${#pkg_list_from_file[@]} < 1 )); then
            (( validation_error=validation_error+1 ))
            _msg_error "No package specified in '${packages}'." 0
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg_error "Packages file '${packages}' does not exist." 0
    fi

    # Check if the specified airootfs_image_type is supported
    if typeset -f "_mkairootfs_${airootfs_image_type}" &> /dev/null; then
        if typeset -f "_validate_requirements_airootfs_image_type_${airootfs_image_type}" &> /dev/null; then
            "_validate_requirements_airootfs_image_type_${airootfs_image_type}"
        else
            _msg_warning "Function '_validate_requirements_airootfs_image_type_${airootfs_image_type}' does not exist. Validating the requirements of '${airootfs_image_type}' airootfs image type will not be possible."
        fi
    else
        (( validation_error=validation_error+1 ))
        _msg_error "Unsupported image type: '${airootfs_image_type}'" 0
    fi
}

_validate_requirements_buildmode_iso() {
    _validate_common_requirements_buildmode_iso_netboot
    _validate_common_requirements_buildmode_all
    # Check if the specified bootmodes are supported
    if (( ${#bootmodes[@]} < 1 )); then
        (( validation_error=validation_error+1 ))
        _msg_error "No boot modes specified in '${profile}/profiledef.sh'." 0
    fi
    for bootmode in "${bootmodes[@]}"; do
        if typeset -f "_make_bootmode_${bootmode}" &> /dev/null; then
            if typeset -f "_validate_requirements_bootmode_${bootmode}" &> /dev/null; then
                "_validate_requirements_bootmode_${bootmode}"
            else
                _msg_warning "Function '_validate_requirements_bootmode_${bootmode}' does not exist. Validating the requirements of '${bootmode}' boot mode will not be possible."
            fi
        else
            (( validation_error=validation_error+1 ))
            _msg_error "${bootmode} is not a valid boot mode!" 0
        fi
    done

    if ! command -v awk &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': awk is not available on this host. Install 'awk'!" 0
    fi
}

validate_requirements_buildmode_netboot() {
    _validate_requirements_buildmode_all
    local _override_cert_list=()

    if [[ "${sign_netboot_artifacts}" == "y" ]]; then
        # Check if the certificate files exist
        for _cert in "${cert_list[@]}"; do
            if [[ -e "${_cert}" ]]; then
                _override_cert_list+=("$(realpath -- "${_cert}")")
            else
                (( validation_error=validation_error+1 ))
                _msg_error "File '${_cert}' does not exist." 0
            fi
        done
        cert_list=("${_override_cert_list[@]}")
        # Check if there are at least two certificate files
        if (( ${#cert_list[@]} < 2 )); then
            (( validation_error=validation_error+1 ))
            _msg_error "Two certificates are required for codesigning, but '${cert_list[*]}' is provided." 0
        fi
    fi
    _validate_common_requirements_buildmode_iso_netboot
    _validate_common_requirements_buildmode_all
    if ! command -v openssl &> /dev/null; then
        (( validation_error=validation_error+1 ))
        _msg_error "Validating build mode '${_buildmode}': openssl is not available on this host. Install 'openssl'!" 0
    fi
}

# SYSLINUX El Torito
_add_xorrisofs_options_bios.syslinux.eltorito() {
    xorrisofs_options+=(
        # El Torito boot image for x86 BIOS
        '-eltorito-boot' 'syslinux/isolinux.bin'
        # El Torito boot catalog file
        '-eltorito-catalog' 'syslinux/boot.cat'
        # Required options to boot with ISOLINUX
        '-no-emul-boot' '-boot-load-size' '4' '-boot-info-table'
    )
}

# SYSLINUX MBR (isohybrid)
_add_xorrisofs_options_bios.syslinux.mbr() {
    xorrisofs_options+=(
        # SYSLINUX MBR bootstrap code; does not work without "-eltorito-boot syslinux/isolinux.bin"
        '-isohybrid-mbr' "${isofs_dir}/syslinux/isohdpfx.bin"
        # When GPT is used, create an additional partition in the MBR (besides 0xEE) for sectors 0â€“1 (MBR
        # bootstrap code area) and mark it as bootable
        # May allow booting on some systems
        # https://wiki.archlinux.org/title/Partitioning#Tricking_old_BIOS_into_booting_from_GPT
        '--mbr-force-bootable'
        # Move the first partition away from the start of the ISO to match the expectations of partition editors
        # May allow booting on some systems
        # https://dev.lovelyhq.com/libburnia/libisoburn/src/branch/master/doc/partition_offset.wiki
        '-partition_offset' '16'
    )
}

# systemd-boot in an attached EFI system partition
_add_xorrisofs_options_uefi-x64.systemd-boot.esp() {
    # Move the first partition away from the start of the ISO, otherwise the GPT will not be valid and ISO 9660
    # partition will not be mountable
    # shellcheck disable=SC2076
    [[ " ${xorrisofs_options[*]} " =~ ' -partition_offset ' ]] || xorrisofs_options+=('-partition_offset' '16')
    # Attach efiboot.img as a second partition and set its partition type to "EFI system partition"
    xorrisofs_options+=('-append_partition' '2' 'C12A7328-F81F-11D2-BA4B-00A0C93EC93B' "${work_dir}/efiboot.img")
    # Ensure GPT is used as some systems do not support UEFI booting without it
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]]; then
        # A valid GPT prevents BIOS booting on some systems, instead use an invalid GPT (without a protective MBR).
        # The attached partition will have the EFI system partition type code in MBR, but in the invalid GPT it will
        # have a Microsoft basic partition type code.
        if [[ ! " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.eltorito ' ]]; then
            # If '-isohybrid-gpt-basdat' is specified before '-e', then the appended EFI system partition will have the
            # EFI system partition type ID/GUID in both MBR and GPT. If '-isohybrid-gpt-basdat' is specified after '-e',
            # the appended EFI system partition will have the Microsoft basic data type GUID in GPT.
            if [[ ! " ${xorrisofs_options[*]} " =~ ' -isohybrid-gpt-basdat ' ]]; then
                xorrisofs_options+=('-isohybrid-gpt-basdat')
            fi
        fi
    else
        # Use valid GPT if BIOS booting support will not be required
        xorrisofs_options+=('-appended_part_as_gpt')
    fi
}

# systemd-boot via El Torito
_add_xorrisofs_options_uefi-x64.systemd-boot.eltorito() {
    # shellcheck disable=SC2076
    if [[ " ${bootmodes[*]} " =~ ' uefi-x64.systemd-boot.esp ' ]]; then
        # systemd-boot in an attached EFI system partition via El Torito
        xorrisofs_options+=(
            # Start a new El Torito boot entry for UEFI
            '-eltorito-alt-boot'
            # Set the second partition as the El Torito UEFI boot image
            '-e' '--interval:appended_partition_2:all::'
            # Boot image is not emulating floppy or hard disk; required for all known boot loaders
            '-no-emul-boot'
        )
        # A valid GPT prevents BIOS booting on some systems, use an invalid GPT instead.
        if [[ " ${bootmodes[*]} " =~ ' bios.syslinux.mbr ' ]]; then
            # If '-isohybrid-gpt-basdat' is specified before '-e', then the appended EFI system partition will have the
            # EFI system partition type ID/GUID in both MBR and GPT. If '-isohybrid-gpt-basdat' is specified after '-e',
            # the appended EFI system partition will have the Microsoft basic data type GUID in GPT.
            if [[ ! " ${xorrisofs_options[*]} " =~ ' -isohybrid-gpt-basdat ' ]]; then
                xorrisofs_options+=('-isohybrid-gpt-basdat')
            fi
        fi
    else
        # The ISO will not contain a GPT partition table, so to be able to reference efiboot.img, place it as a
        # file inside the ISO 9660 file system
        install -d -m 0755 -- "${isofs_dir}/EFI/archiso"
        cp -a -- "${work_dir}/efiboot.img" "${isofs_dir}/EFI/archiso/efiboot.img"
        # systemd-boot in an embedded efiboot.img via El Torito
        xorrisofs_options+=(
            # Start a new El Torito boot entry for UEFI
            '-eltorito-alt-boot'
            # Set efiboot.img as the El Torito UEFI boot image
            '-e' 'EFI/archiso/efiboot.img'
            # Boot image is not emulating floppy or hard disk; required for all known boot loaders
            '-no-emul-boot'
        )
    fi
    # Specify where to save the El Torito boot catalog file in case it is not already set by bios.syslinux.eltorito
    # shellcheck disable=SC2076
    [[ " ${bootmodes[*]} " =~ ' bios.' ]] || xorrisofs_options+=('-eltorito-catalog' 'EFI/boot.cat')
}

# Build bootstrap image
_build_bootstrap_image() {
    local _bootstrap_parent
    _bootstrap_parent="$(dirname -- "${pacstrap_dir}")"

    [[ -d "${out_dir}" ]] || install -d -- "${out_dir}"

    cd -- "${_bootstrap_parent}"

    _msg_info "Creating bootstrap image..."
    bsdtar -cf - "root.${arch}" | gzip -cn6 > "${out_dir}/${image_name}"
    _msg_info "Done!"
    du -h -- "${out_dir}/${image_name}"
    cd -- "${OLDPWD}"
}

# Build ISO
_build_iso_image() {
    local xorriso_options=() xorrisofs_options=()
    local bootmode

    [[ -d "${out_dir}" ]] || install -d -- "${out_dir}"

    if [[ "${quiet}" == "y" ]]; then
        # The when xorriso is run in mkisofs compatibility mode (xorrisofs), the mkisofs option -quiet is interpreted
        # too late (e.g. messages about SOURCE_DATE_EPOCH still get shown).
        # Instead use native xorriso option to silence the output.
        xorriso_options=('-report_about' 'SORRY' "${xorriso_options[@]}")
    fi

    # Add required xorrisofs options for each boot mode
    for bootmode in "${bootmodes[@]}"; do
        typeset -f "_add_xorrisofs_options_${bootmode}" &> /dev/null && "_add_xorrisofs_options_${bootmode}"
    done
    
    rm -f -- "${out_dir}/${image_name}"
    _msg_info "Creating ISO image..."
    if [[ "${quiet}" == "y" ]]; then
        xorriso "${xorriso_options[@]}" -as mkisofs \
            -iso-level 3 \
            -full-iso9660-filenames \
            -joliet \
            -joliet-long \
            -volid "${iso_label}" \
            -appid "${iso_application}" \
            -publisher "${iso_publisher}" \
            -preparer "prepared by ${app_name}" \
            "${xorrisofs_options[@]}" \
            -output "${out_dir}/${image_name}" \
            "${isofs_dir}/" 2> /dev/null
    else
        xorriso -as mkisofs \
            -iso-level 3 \
            -full-iso9660-filenames \
            -joliet \
            -joliet-long \
            -volid "${iso_label}" \
            -appid "${iso_application}" \
            -publisher "${iso_publisher}" \
            -preparer "prepared by ${app_name}" \
            "${xorrisofs_options[@]}" \
            -output "${out_dir}/${image_name}" \
            "${isofs_dir}/"
    fi
    _mkchecksum_iso
    if [[ -n "${gpg_key}" ]]; then
        _mksignature_iso
    fi
    _msg_info "Done!"
    echo
    _msg_info "$(du -h -- "${out_dir}/${image_name}")"
}

_iso_version_options() {
    if grep -q optimus <<< "${iso_version_options[@]}"; then
        iso_version_options=(${iso_version_options[@]/nvidia})
    fi
    iso_version_options=($(sed 's/\s/\n/g' <<< "${iso_version_options[@]}" | sort | sed ':a;N;$!ba;s/\n/-/g'))
}

# Read profile's values from profiledef.sh
_read_profile() {
    if [[ -z "${profile}" ]]; then
        _msg_error "No profile specified!" 1
    fi
    if [[ ! -d "${profile}" ]]; then
        _msg_error "Profile '${profile}' does not exist!" 1
    elif [[ ! -e "${profile}/profiledef.sh" ]]; then
        _msg_error "Profile '${profile}' is missing 'profiledef.sh'!" 1
    else
        cd -- "${profile}"

        # Source profile's variables
        source "${profile}/profiledef.sh"

        # Resolve paths of files that are expected to reside in the profile's directory
        [[ -n "${packages}" ]] || packages="${profile}/packages.${arch}"
        packages="$(realpath -- "${packages}")"
        if [[ -n "${lang}" ]]; then
          packages_locales="$(realpath -- "${profile}/lang/${lang}/packages.${arch}")"
        fi
        pacman_conf="$(realpath -- "${pacman_conf}")"
        [[ -n "${pacman_testing_conf}" ]] && pacman_testing_conf="$(realpath -- "${pacman_testing_conf}")"

        # Resolve paths of files that may reside in the profile's directory
        if [[ -z "$bootstrap_packages" ]] && [[ -e "${profile}/bootstrap_packages.${arch}" ]]; then
            bootstrap_packages="${profile}/bootstrap_packages.${arch}"
            bootstrap_packages="$(realpath -- "${bootstrap_packages}")"
            pacman_conf="$(realpath -- "${pacman_conf}")"
        fi

        cd -- "${OLDPWD}"
    fi
}

# Validate set options
_validate_options() {
    local validation_error=0 _buildmode

    _msg_info "Validating options..."
    # Check if pacman configuration file exists
    if [[ ! -e "${pacman_conf}" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "File '${pacman_conf}' does not exist." 0
    fi

    # Check if the specified buildmodes are supported
    for _buildmode in "${buildmodes[@]}"; do
        if typeset -f "_build_buildmode_${_buildmode}" &> /dev/null; then
            if typeset -f "_validate_requirements_buildmode_${_buildmode}" &> /dev/null; then
                "_validate_requirements_buildmode_${_buildmode}"
            else
                _msg_warning "Function '_validate_requirements_buildmode_${_buildmode}' does not exist. Validating the requirements of '${_buildmode}' build mode will not be possible."
            fi
        else
            (( validation_error=validation_error+1 ))
            _msg_error "${_buildmode} is not a valid build mode!" 0
        fi
    done

    # Check if pacman-testing configuration file exists
    if [[ -n "${pacman_testing_conf}" && ! -e "${pacman_testing_conf}" ]]; then
        (( validation_error=validation_error+1 ))
        _msg_error "File '${pacman_testing_conf}' does not exist." 0
    fi

    if (( validation_error )); then
        _msg_error "${validation_error} errors were encountered while validating the profile. Aborting." 1
    fi
    _msg_info "Done!"
}

# set overrides from mkarchiso option parameters, if present
# Set defaults and, if present, overrides from aui-mkiso command line option parameters
_set_overrides() {
    # Set variables that have command line overrides
    [[ ! -v override_buildmodes ]] || buildmodes=("${override_buildmodes[@]}")
    if (( ${#buildmodes[@]} < 1 )); then
        buildmodes+=('iso')
    fi
    if [[ -v override_work_dir ]]; then
        work_dir="${override_work_dir}"
    elif [[ -z "${work_dir}" ]]; then
        work_dir='./work'
    fi
    work_dir="$(realpath -- "${work_dir}")"
    if [[ -v override_out_dir ]]; then
        out_dir="${override_out_dir}"
    elif [[ -z "${out_dir}" ]]; then
        out_dir='./out'
    fi
    out_dir="$(realpath -- "${out_dir}")"
    if [[ -v override_pacman_conf ]]; then
        pacman_conf="${override_pacman_conf}"
    elif [[ -z "${pacman_conf}" ]]; then
        pacman_conf="/etc/pacman.conf"
    fi
    pacman_conf="$(realpath -- "${pacman_conf}")"
    if [[ -v override_pacman_testing_conf ]]; then
        pacman_testing_conf="${override_pacman_testing_conf}"
    elif [[ -z "${pacman_testing_conf}" ]]; then
        pacman_testing_conf="/etc/pacman_testing.conf"
    fi
    pacman_testing_conf="$(realpath -- "${pacman_testing_conf}")"
    # TODO: allow overriding bootstrap_pkg_list
    if [[ -v override_iso_label ]]; then
        iso_label="${override_iso_label}"
    elif [[ -z "${iso_label}" ]]; then
        iso_label="${app_name^^}"
    fi
    if [[ -v override_iso_publisher ]]; then
        iso_publisher="${override_iso_publisher}"
    elif [[ -z "${iso_publisher}" ]]; then
        iso_publisher="${app_name}"
    fi
    if [[ -v override_iso_application ]]; then
        iso_application="${override_iso_application}"
    elif [[ -z "${iso_application}" ]]; then
        iso_application="${app_name} iso"
    fi
    if [[ -v override_install_dir ]]; then
        install_dir="${override_install_dir}"
    elif [[ -z "${install_dir}" ]]; then
        install_dir="${app_name}"
    fi
    [[ ! -v override_gpg_key ]] || gpg_key="${override_gpg_key}"
    [[ ! -v override_gpg_sender ]] || gpg_sender="$override_gpg_sender"
    if [[ -v override_cert_list ]]; then
        sign_netboot_artifacts="y"
    fi
    [[ ! -v override_cert_list ]] || cert_list+=("${override_cert_list[@]}")
    if [[ -v override_quiet ]]; then
        quiet="${override_quiet}"
    elif [[ -z "${quiet}" ]]; then
        quiet="y"
    fi
    if [[ -v override_iso_name ]]; then
        image_name="${override_iso_name}"
    fi
}

_export_gpg_publickey() {
    rm -f -- "${work_dir}/pubkey.gpg"
    gpg --batch --no-armor --output "${work_dir}/pubkey.gpg" --export "${gpg_key}"
}

_make_version() {
    local osrelease

    _msg_info "Creating version files..."
    if [[ "${buildmode}" == @("iso"|"netboot") ]]; then
        if [[ -z "${iso_version}" ]]; then
            iso_version="$(pacman --sysroot "${work_dir}/x86_64/airootfs" -Q linux 2> /dev/null | \
                           cut -d' ' -f2 | \
                           sed s'/\./_/g; s/_arch.*//; s/^/linux_/')${iso_version_options[0]:+-${iso_version_options[0]}}${lang:+-${lang}}-$(date +%m%d)"
        fi
        install -d -m 0755 -- "${isofs_dir}/${install_dir}"
        # Write version file to ISO 9660
        printf '%s\n' "${iso_version}" > "${isofs_dir}/${install_dir}/version"
        # Write grubenv with version information to ISO 9660
        printf '%.1024s' "$(printf '# GRUB Environment Block\nNAME=%s\nVERSION=%s\n%s' \
            "${iso_name}" "${iso_version}" "$(printf '%0.1s' "#"{1..1024})")" \
            > "${isofs_dir}/${install_dir}/grubenv"
    fi
    # Write version file to system installation dir
    rm -f -- "${pacstrap_dir}/version"
    printf '%s\n' "${iso_version:="$(date +%m%d)"}" > "${pacstrap_dir}/version"

    # Append IMAGE_ID & IMAGE_VERSION to os-release
    _os_release="$(realpath -- "${pacstrap_dir}/etc/os-release")"
    if [[ ! -e "${pacstrap_dir}/etc/os-release" && -e "${pacstrap_dir}/usr/lib/os-release" ]]; then
        _os_release="$(realpath -- "${pacstrap_dir}/usr/lib/os-release")"
    fi
    if [[ "${_os_release}" != "${pacstrap_dir}"* ]]; then
        _msg_warning "os-release file '${_os_release}' is outside of valid path."
    else
        [[ ! -e "${_os_release}" ]] || sed -i '/^IMAGE_ID=/d;/^IMAGE_VERSION=/d' "${_os_release}"
        printf 'IMAGE_ID=%s\nIMAGE_VERSION=%s\n' "${iso_name}" "${iso_version}" >> "${_os_release}"
    fi
    _msg_info "Done!"

}

_make_pkglist() {
    _msg_info "Creating a list of installed packages on live-enviroment..."
    case "${buildmode}" in
        "bootstrap")
            pacman -Q --sysroot "${pacstrap_dir}" > "${pacstrap_dir}/pkglist.${arch}.txt"
            ;;
        "iso"|"netboot")
            install -d -m 0755 -- "${isofs_dir}/${install_dir}"
            pacman -Q --sysroot "${pacstrap_dir}" > "${isofs_dir}/${install_dir}/pkglist.${arch}.txt"
            ;;
    esac
    _msg_info "Done!"
}

# build the base for an ISO and/or a netboot target
_build_iso_base() {
    local run_once_mode="base"
    local buildmode_packages="${packages}"
    # Set the package list to use
    local buildmode_pkg_list=("${pkg_list[@]}")
    # Set up essential directory paths
    pacstrap_dir="${work_dir}/${arch}/airootfs"
    isofs_dir="${work_dir}/iso"

    # Create working directory
    [[ -d "${work_dir}" ]] || install -d -- "${work_dir}"
    # Write build date to file or if the file exists, read it from there
    if [[ -e "${work_dir}/build_date" ]]; then
        SOURCE_DATE_EPOCH="$(<"${work_dir}/build_date")"
    else
        printf '%s\n' "$SOURCE_DATE_EPOCH" > "${work_dir}/build_date"
    fi

    _show_config
    _run_once _make_pacman_conf
    [[ -n "${pacman_testing_conf}" ]] && _run_once _make_pacman_testing_conf
    [[ "${build_zfs_packages}" == "y" ]] && _run_once _build_zfs_packages
    [[ -z "${gpg_key}" ]] || _run_once _export_gpg_publickey
    _run_once _make_custom_airootfs
    _run_once _make_packages
    [[ -n "${pkg_testing_list[*]}" ]] && _run_once _make_packages_testing
    [[ -n "${user_pkg_dir}" && -d "${user_pkg_dir}" ]] && _run_once _make_packages_upgrade
    _run_once _make_version
    _run_once _make_customize_airootfs
    _run_once _make_setup_mkinitcpio
    _run_once _make_pkglist
    if [[ "${buildmode}" == 'netboot' ]]; then
        _run_once _make_boot_on_iso9660
    else
        _make_bootmodes
    fi
    _run_once _cleanup_pacstrap_dir
    _run_once _make_aui
    _run_once _prepare_airootfs_image
}

# Build the bootstrap buildmode
_build_buildmode_bootstrap() {
    local image_name="${iso_name}-bootstrap-${iso_version:-"$(date +%m%d)"}-${arch}.tar.gz"
    local run_once_mode="${buildmode}"
    local buildmode_packages="${bootstrap_packages}"
    # Set the package list to use
    local buildmode_pkg_list=("${bootstrap_pkg_list[@]}")

    # Set up essential directory paths
    pacstrap_dir="${work_dir}/${arch}/bootstrap/root.${arch}"
    [[ -d "${work_dir}" ]] || install -d -- "${work_dir}"
    install -d -m 0755 -o 0 -g 0 -- "${pacstrap_dir}"

    [[ "${quiet}" == "y" ]] || _show_config
    _run_once _make_pacman_conf
    _run_once _make_packages
    _run_once _make_version
    _run_once _make_pkglist
    _run_once _cleanup_pacstrap_dir
    _run_once _build_bootstrap_image
}

# Build the netboot buildmode
_build_buildmode_netboot() {
    local run_once_mode="${buildmode}"

    _build_iso_base
    if [[ -v cert_list ]]; then
        _run_once _sign_netboot_artifacts
    fi
    _run_once _export_netboot_artifacts
}

# Build the ISO buildmode
_build_buildmode_iso() {
    local image_name=""
    local run_once_mode="${buildmode}"
    _build_iso_base
    _run_once _build_iso_image
}

# build all buildmodes
_build() {
    local buildmode
    local run_once_mode="build"

    for buildmode in "${buildmodes[@]}"; do
        _run_once "_build_buildmode_${buildmode}"
    done
}

_build_zfs_packages () {
    if [[ "${SCRIPTUSER}" == 'root' || -z "${SUDO_USER:-}" ]]; then
        echo
        echo 'Option for ZFS support:'
        echo 'The script must be run from a _user session_ using sudo!'
        echo 'Aborting...'
        exit 0
    fi

    local _WD _auiwork _ar64 _linuxversion _modulesversion _zfspackages _zfssources _zfsversion
    local _ZFSPUBKEY _KEYSERVER
    _WD="$(pwd)"
    _auiwork="${_WD}/$(mktemp -u auiwork.XXXXXXXX)"
    _ar64="${_auiwork}/archroot64"
    _ZFSPUBKEY="6AD860EED4598027"
    _KEYSERVER="ha.pool.sks-keyservers.net"

    # Retrieve ZFS on Linux public key
    if ! sudo --user "${SCRIPTUSER}" gpg --list-public-keys "${_ZFSPUBKEY}" &> /dev/null; then
        echo
        read -r -n1 -p 'Retrieve missing ZFS on Linux public key (N/y)? '
        echo
        if [[ ! "${REPLY}" =~ ^[Yy]$ ]]; then
            echo 'Operation canceled by user!'
            exit 0
        fi
        if ! sudo --user "${SCRIPTUSER}" gpg --keyserver "${_KEYSERVER}" --recv "${_ZFSPUBKEY}"; then
            echo
            echo "Retreiving ZFS public key ${_ZFSPUBKEY} failed, aborting!"
            echo
        fi
    fi

    if ! pacman -Q devtools &> /dev/null; then
        echo 'devtools package not installed, aborting!'
        exit 0
    fi
    if ! pacman -Q pacman-contrib &> /dev/null; then
        echo 'pacman-contrib package not installed, aborting!'
        exit 0
    fi
    mkdir -p -- "${_WD}/work/pkgdir"
    mkdir -p -- "${_ar64}"
    chmod a+x -- "${_auiwork}"
    mapfile -t _zfssources < <(curl --silent --retry 3 --retry-connrefused --fail -- \
                   https://api.github.com/repos/openzfs/zfs/releases/latest | \
                   grep browser_download_url | cut -d':' -f2- | sed 's/\"//g; s/^[[:blank:]]*//')
    _zfsversion="${_zfssources[0]%/zfs-*}"
    _zfsversion="${_zfsversion#*-}"
    if [[ -z "${_zfsversion}" ]]; then
        echo 'Retrieving ZFS data failed, aborting!'
        exit 0
    fi
    _msg_info "Preparing zfs chroot"
    if [[ "${quiet}" == "y" ]]; then
        mkarchroot -c /var/cache/pacman/pkg -- "${_ar64}/root" base linux linux-headers base-devel &> /dev/null
    else
        mkarchroot -c /var/cache/pacman/pkg -- "${_ar64}/root" base linux linux-headers base-devel
    fi
    _msg_info "Done!"
    if [[ -n "${pkg_testing_list[*]}" ]]; then
        for _package in "${pkg_testing_list[@]}"; do
            if [[ "${_package}" = 'linux' ]]; then
                _msg_info "Installing linux package from testing"
                if [[ "${quiet}" == "y" ]]; then
                    pacstrap -C "${work_dir}/pacman-testing.conf" -c -G -M -- "${_ar64}/root" linux linux-headers &> /dev/null
                else
                    pacstrap -C "${work_dir}/pacman-testing.conf" -c -G -M -- "${_ar64}/root" linux linux-headers
                fi
                _msg_info "Done!"
                break
            fi
        done
    fi
    _linuxversion=$(pacman --sysroot "${_ar64}/root" -Q linux | cut -d' ' -f2)
    if [[ "$(cut -d'.' -f3 <<< "${_linuxversion}")" =~ 'arch' ]]; then
        _modulesversion="${_linuxversion%.arch*}.0-${_linuxversion##*.}"
    else
        _modulesversion="${_linuxversion%.arch*}-${_linuxversion##*.}"
    fi
    cp -arT -- "${profile}/aui/zfsonlinux" "${_auiwork}/zfsonlinux"
    sed -i -- "s/%ZFSVERSION%/${_zfsversion}/
               s/%LINUXVERSION%/${_linuxversion}/
               s/%MODULESVERSION%/${_modulesversion}/" \
               "${_auiwork}/zfsonlinux/zfs-utils/PKGBUILD" \
               "${_auiwork}/zfsonlinux/zfs-linux/PKGBUILD"
    cd -- "${_auiwork}/zfsonlinux/zfs-utils/"
    for _zfslink in "${_zfssources[@]}"; do
        if [[ "${_zfslink}" =~ '.tar.gz'$ ]]; then
            curl --silent --retry 3 --retry-connrefused --fail -L -O "${_zfslink}"
            curl --silent --retry 3 --retry-connrefused --fail -L -O "${_zfslink}".asc
            break
        fi
    done
    cp -a -- zfs-*.tar.gz{,.asc} ../zfs-linux
    chown -R "${SCRIPTUSER}": -- "${_auiwork}/zfsonlinux"
    _msg_info "Creating PKGBUILDs"
    if [[ "${quiet}" == "y" ]]; then
        sudo --user "${SCRIPTUSER}" makepkg --geninteg >> PKGBUILD 2> /dev/null
        sudo --user "${SCRIPTUSER}" updpkgsums 2> /dev/null
    else
        sudo --user "${SCRIPTUSER}" makepkg --geninteg >> PKGBUILD
        sudo --user "${SCRIPTUSER}" updpkgsums
    fi
    cd -- "${_auiwork}/zfsonlinux/zfs-linux/"
    if [[ "${quiet}" == "y" ]]; then
        sudo --user "${SCRIPTUSER}" makepkg --geninteg >> PKGBUILD 2> /dev/null
        sudo --user "${SCRIPTUSER}" updpkgsums 2> /dev/null
    else
        sudo --user "${SCRIPTUSER}" makepkg --geninteg >> PKGBUILD
        sudo --user "${SCRIPTUSER}" updpkgsums
    fi
    _msg_info "Done!"
    cd -- "${_auiwork}/zfsonlinux/zfs-utils/"
    _msg_info "Building zfs-utils"
    if [[ "${quiet}" == "y" ]]; then
        sudo --user "${SCRIPTUSER}" \
        makechrootpkg -r "${_ar64}" -- --cleanbuild --clean --force --syncdeps --needed --noconfirm --noprogressbar &> /dev/null
    else
        sudo --user "${SCRIPTUSER}" \
        makechrootpkg -r "${_ar64}" -- --cleanbuild --clean --force --syncdeps --needed --noconfirm --noprogressbar
    fi
    _msg_info "Done!"
    mapfile -t _zfspackages < <(find -- "${_auiwork}/zfsonlinux/" | grep -e '\.pkg\.tar\.zst$' -e '\.pkg\.tar\.xz$')
    cd -- "${_auiwork}/zfsonlinux/zfs-linux/"
    _msg_info "Building zfs-linux"
    if [[ "${quiet}" == "y" ]]; then
        sudo --user "${SCRIPTUSER}" \
        makechrootpkg -r "${_ar64}" -I "${_zfspackages[0]}" -- --cleanbuild --clean --force --syncdeps --needed --noconfirm --noprogressbar &> /dev/null
    else
        sudo --user "${SCRIPTUSER}" \
        makechrootpkg -r "${_ar64}" -I "${_zfspackages[0]}" -- --cleanbuild --clean --force --syncdeps --needed --noconfirm --noprogressbar
    fi
    _msg_info "Done!"
    mapfile -t _zfspackages < <(find -- "${_auiwork}/zfsonlinux/" | grep -e '\.pkg\.tar\.zst$' -e '\.pkg\.tar\.xz$')
    if [[ -n "${user_pkg_dir}" ]]; then
        cp -- "${_zfspackages[@]}" "${user_pkg_dir}"
    else
        cp -- "${_zfspackages[@]}" "${_WD}/work/pkgdir"
        user_pkg_dir="${_WD}/work/pkgdir"
    fi
    rm -r -- "${_auiwork}"
    cd -- "${_WD}"
}

OPTS=$(getopt -o '?A:C:c:D:g:G:hL:l:m:N:o:P:p:vw:' \
              -l 'addi3wm,addpkg:,addpkgtesting:,application:,embeddir:' \
              -l 'add-i3-wm,add-pkg:,add-pkg-testing:,build-modes:,cert:,embed-dir:' \
              -l 'gpgkey:,gpgsender:,installdir:,label:,language:,nvidia,optimus' \
              -l 'outdir:,pacman-testing-conf:,pkgdir:,publisher:' \
              -l 'install-dir:,out-dir:,pacmantestingconf:,pkg-dir:' \
              -l 'verbose,workdir:,work-dir:,zfs' \
              -l 'help' \
              -n "${app_name}" -- "$@")
[[ $? -eq 0 ]] || _usage 1
eval set -- "${OPTS}"
unset OPTS

while true; do
    case "${1}" in
        '-?'|'-h'|'--help')
            _usage 0 ;;
        '-p'|'--add-pkg'|'--addpkg')
            pkg_list_additions+=($(tr ',' ' ' <<< "${2}"))
            shift 2 ;;
        '--add-pkg-testing'|'--addpkgtesting')
            pkg_testing_list=($(tr ',' ' ' <<< "${2}"))
            shift 2 ;;
        '-A'|'--application')
            override_iso_application="${2}"
            shift 2 ;;
        '--add-i3-wm'|'--addi3wm')
            pkg_list_additions+=(i3-gaps feh dmenu i3status wmctrl rxvt-unicode)
            iso_version_options+=(i3)
            shift ;;
        '-C')
            override_pacman_conf="$(realpath -- "${2}")"
            shift 2 ;;
        '-c'|'--cert')
            read -r -d ',' -a override_cert_list <<< "${2}"
            shift 2 ;;
        '-D'|'--install-dir'|'--installdir')
            override_install_dir="${2}"
            shift 2 ;;        
        '--embed-dir'|'--embeddir')
            embed_dir="${2}"
            shift 2 ;;
        '-g'|'--gpgkey')
            override_gpg_key="${2}"
            shift 2 ;;
        '-G'|'--gpgsender')
            override_gpg_sender="${2}"
            shift 2 ;;
        '-L'|'--label')
            override_iso_label="${2}"
            shift 2 ;;
        '-l'|'--language')
            case "${2}" in
                'cz'|'cs_CZ') lang="cs_CZ";;
                'de'|'de_DE') lang="de_DE";;
                'es'|'es_ES') lang="es_ES";;
                'fr'|'fr_FR') lang="fr_FR";;
                'gr'|'el_GR') lang="el_GR";;
                'hu'|'hu_HU') lang="hu_HU";;
                'it'|'it_IT') lang="it_IT";;
                'nl'|'nl_NL') lang="nl_NL";;
                'pl'|'pl_PL') lang="pl_PL";;
                'pt'|'pt_PT') lang="pt_PT";;
                'ro'|'ro_RO') lang="ro_RO";;
                'rs'|'sr_RS@latin') lang="sr_RS@latin";;
                'ru'|'ru_RU') lang="ru_RU";;
                'tr'|'tr_TR') lang="tr_TR";;
                'ua'|'uk_UA') lang="uk_UA";;
                *) _usage 1;;
            esac
            shift 2 ;;
        '-m'|'--build-modes')
            IFS=',' read -r -a override_buildmodes <<< "${2}"
            shift 2 ;;
        '-N'|'--name')
            override_iso_name="${2}"
            shift 2 ;;
        '--nvidia')
            pkg_list_additions+=(nvidia nvidia-settings bbswitch)
            iso_version_options+=(nvidia)
            shift ;;
        '--optimus')
            pkg_list_additions+=(nvidia nvidia-settings nvidia-prime)
            iso_version_options+=(optimus)
            shift ;;
        '-o'|'--out-dir'|'--outdir')
            override_out_dir="${2}"
            shift 2 ;;
        '--pacman-testing-conf'|'--pacmantestingconf')
            override_pacman_testing_conf="$(realpath -- "${2}")"
            shift 2 ;;
        '--pkg-dir'|'--pkgdir')
            user_pkg_dir="${2}"
            shift 2 ;;
        '-P'|'--publisher')
            override_iso_publisher="${2}"
            shift 2 ;;
        '-v'|'--verbose')
            override_quiet="n"
            shift ;;
        '-w'|'--workdir'|'--work-dir')
            override_work_dir="${2}"
            shift 2 ;;
        '--zfs')
            build_zfs_packages="y"
            iso_version_options+=(zfs)
            shift ;;
        '--')
            shift
            break ;;
    esac
done

if [[ $# -eq 0 ]]; then
    _msg_error "No profile specified" 0
    _usage 1
fi
if (( EUID != 0 )); then
    _msg_error "${app_name} must be run as root." 1
fi

if [[ ! -d "$(realpath -- "${1}")" ]]; then
    set -- "${directory_profiles}/${1}"
fi
profile="$(realpath -- "${1}")"

[[ -n "${iso_version_options[*]}" ]] && _iso_version_options
_read_profile
_set_overrides
echo
if [[ -d "${work_dir}" ]]; then
    _msg_info "WORKING DIRECTORY '${work_dir}' ALREADY EXISTS! REMOVE DIRECTORY BEFORE BUILDING A NEW ISO." && 
    echo
    exit 0
fi
_validate_options
_build
_msg_info "Success!"

# vim:ts=4:sw=4:et:
